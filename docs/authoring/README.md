# Authoring (YAML) Manual

This document explains **Authoring**: the YAML model that defines entities, fields, views, mappings, and backend-native queries.

## Table of Contents
- [1. Purpose of Authoring](#1-purpose-of-authoring)
- [2. Authoring model: classes and YAML shortnames](#2-authoring-model-classes-and-yaml-shortnames)
  - [2.1 EntityAuthoring (root document)](#21-entityauthoring-root-document)
  - [2.2 AuthoringKind (kind)](#22-authoringkind-kind)
  - [2.3 FieldDef (fields)](#23-fielddef-fields)
  - [2.4 TypeRef (type DSL)](#24-typeref-type-dsl)
  - [2.5 ViewDef (views)](#25-viewdef-views)
  - [2.6 SqlViewDef (sqlView)](#26-sqlviewdef-sqlview)
  - [2.7 SqlAliasDef (sqlView.aliases)](#27-sqlaliasdef-sqlviewaliases)
  - [2.8 AuthoringRegistry (lookup)](#28-authoringregistry-lookup)
  - [2.9 UserType / UserTypeRegistry](#29-usertype--usertyperegistry)
  - [2.10 DiscoveredUserTypeRegistry (discovery + synthesis)](#210-discoveredusertyperegistry-discovery--synthesis)
  - [2.11 UserTypeProvider / DefaultUserTypeProvider](#211-usertypeprovider--defaultusertypeprovider)
  - [2.12 ViewMappings (mapping helpers)](#212-viewmappings-mapping-helpers)
  - [2.13 TypeIds (canonical ids)](#213-typeids-canonical-ids)
- [3. Default UserTypes](#3-default-usertypes)
  - [3.1 Global scalar UserTypes](#31-global-scalar-usertypes)
  - [3.2 Global list UserTypes](#32-global-list-usertypes)
  - [3.3 Synthesized container UserTypes](#33-synthesized-container-usertypes)
- [4. End-to-end example (Order.yml style)](#4-end-to-end-example-orderyml-style)

---

## 1. Purpose of Authoring
Authoring is the **single source of truth** that connects:
- Your **logical domain model** (property paths like `customer.firstName`)
- To the **physical store** (SQL columns/expressions or Mongo document paths)
- And to **backend-native query execution** (`sqlView.sql` for JDBC or filter/pipeline for Mongo)

Nativa uses authoring for:
- Query rendering (filters/sorts/page/groupBy)
- DML planning (insert/upsert/update/delete) via mappings
- Result mapping (JDBC column labels via `label`)
- Governance mapping (`attrs.governanceKey`)
- Code generation (POJOs + registries)

---

## 2. Authoring model: classes and YAML shortnames
All model classes live under `io.intellixity.nativa.persistence.authoring.*` and are loaded from YAML by:
- `io.intellixity.nativa.persistence.authoring.yaml.YamlEntityAuthoringLoader`

### 2.1 EntityAuthoring (root document)
Class: `EntityAuthoring`

YAML shortnames (root keys):
- **`type`** → `EntityAuthoring.type`
- **`kind`** → `EntityAuthoring.kind` (see `AuthoringKind`)
- **`source`** → `EntityAuthoring.source` (required for `ENTITY`)
- **`javaType`** → `EntityAuthoring.javaType` (required, must be FQCN)
- **`generatePojo`** → `EntityAuthoring.generatePojo` (default `true`)
- **`fields`** → `EntityAuthoring.fields` (map of `FieldDef`)
- **`views`** → `EntityAuthoring.views` (map of `ViewDef`)

Minimal example:

```yaml
type: Customer
kind: ENTITY
source: customers
javaType: io.intellixity.nativa.examples.domain.Customer
generatePojo: true
fields: {}
views: {}
```

### 2.2 AuthoringKind (kind)
Class: `AuthoringKind`

YAML shortname:
- **`kind`**: `ENTITY` or `VALUE`

Rules:
- `ENTITY`: must have `source`
- `VALUE`: must not have `source` (used for value objects / inline types)

### 2.3 FieldDef (fields)
Class: `FieldDef`

YAML shortnames (inside `fields.<fieldName>`):
- **`type`** → `FieldDef.type` (Type DSL; see below)
- **`nullable`** → `FieldDef.nullable` (default `false`)
- **`key`** → `FieldDef.key` (default `false`)
- **`autoGenerated`** → `FieldDef.autoGenerated` (default `false`)
- **`attrs`** → `FieldDef.attrs` (free-form map)

Example:

```yaml
fields:
  id: { type: uuid, key: true, autoGenerated: true }
  tenantId: { type: string, attrs: { governanceKey: tenantId } }
  email: { type: string, nullable: true }
```

### 2.4 TypeRef (type DSL)
Classes:
- `TypeRef` (interface)
- `ScalarTypeRef`
- `RefTypeRef`
- `ListTypeRef`
- `SetTypeRef`
- `ArrayTypeRef`
- `MapTypeRef`

YAML shortname:
- **`type`**: a string parsed by `TypeRefParser`

Supported syntax:
- scalar: `string`, `int`, `long`, `double`, `bool`, `uuid`, `instant`, `json`, ...
- reference: `ref(Customer)`
- value reference: `value(Address)`
- containers:
  - `list<T>`
  - `set<T>`
  - `array<T>`
  - `map<K,V>`

Example:

```yaml
fields:
  customer: { type: ref(Customer) }
  address: { type: value(Address) }
  tags: { type: list<string> }
  flags: { type: set<string> }
  payload: { type: json }
  attrs: { type: map<string, string> }
```

Inline VALUE type definition (advanced, handled by `YamlEntityAuthoringLoader`):

```yaml
fields:
  address:
    type: value(Address)
    fields:
      line1: { type: string }
      city: { type: string }
    generatePojo: true
    javaType: io.intellixity.nativa.examples.domain.Address
```

### 2.5 ViewDef (views)
Class: `ViewDef`

YAML shortnames (inside `views.<viewId>`):
- **`mapping`** → `ViewDef.mapping` (map of property path → mapping spec)
- **`sqlView`** → `ViewDef.sqlView` (optional `SqlViewDef`)

Example:

```yaml
views:
  customer_table:
    mapping:
      id: id
      tenantId: tenant_id
    sqlView:
      sql: "select id, tenant_id from customers"
      schema: false
```

### 2.6 SqlViewDef (sqlView)
Class: `SqlViewDef`

YAML shortnames (inside `views.<id>.sqlView`):
- **`sql`** → `SqlViewDef.sql`
  - JDBC: SQL string
  - Mongo: filter object (map) or pipeline list
- **`projection`** → `SqlViewDef.projection` (optional; JDBC projection string / Mongo stage(s))
- **`schema`** → `SqlViewDef.schema` (default `false`) – replace `{schema}` token from `EngineHandle.namespace()`
- **`aliases`** → `SqlViewDef.aliases` (list of `SqlAliasDef`)

### 2.7 SqlAliasDef (sqlView.aliases)
Class: `SqlAliasDef`

YAML shortnames (inside `sqlView.aliases[]`):
- **`name`**
- **`property`**
- **`table`**

Example:

```yaml
sqlView:
  aliases:
    - { name: o, property: order, table: orders }
    - { name: c, property: customer, table: customers }
```

### 2.8 AuthoringRegistry (lookup)
Interfaces/classes:
- `AuthoringRegistry`
- `ListableAuthoringRegistry`
- `InMemoryAuthoringRegistry`

Purpose:
- Load and lookup authoring by `type` and `viewDefId`

### 2.9 UserType / UserTypeRegistry
Interfaces:
- `UserType<T>`
- `UserTypeRegistry`

Purpose:
- Encode/decode values for binds and result mapping
- UserType ids are referenced by `ScalarTypeRef.userTypeId` (e.g. `uuid`, `json`, `list<string>`)

### 2.10 DiscoveredUserTypeRegistry (discovery + synthesis)
Class: `DiscoveredUserTypeRegistry`

Purpose:
- Loads `UserTypeProvider` from `META-INF/nativa.factories`
- Chooses dialect-specific types first, then global types
- Synthesizes container types for `list<...>`, `set<...>`, `array<...>`, `map<k,v>` if no explicit provider exists

### 2.11 UserTypeProvider / DefaultUserTypeProvider
Interfaces/classes:
- `UserTypeProvider`
- `providers.DefaultUserTypeProvider`

Purpose:
- Provide built-in default user types (dialectId = `*`)

### 2.12 ViewMappings (mapping helpers)
Class: `ViewMappings`

Purpose:
- Interprets `view.mapping` entries
- Helpers for `ref(...)`, `label(...)`, etc.

### 2.13 TypeIds (canonical ids)
Class: `TypeIds`

Purpose:
- Canonical `TypeRef` → string id used by backends for binding container types.

---

## 3. Default UserTypes
Default types come from `providers.DefaultUserTypeProvider` (dialectId=`*`), plus synthesis in `DiscoveredUserTypeRegistry`.

### 3.1 Global scalar UserTypes
- `string`
- `int`
- `long`
- `bool`
- `double`
- `uuid`
- `instant`
- `json`

### 3.2 Global list UserTypes
- `list<string>`
- `list<int>`
- `list<long>`
- `list<bool>`
- `list<uuid>`
- `list<double>`

### 3.3 Synthesized container UserTypes
If a concrete user type is not registered, `DiscoveredUserTypeRegistry` synthesizes:
- `list<T>`
- `set<T>`
- `array<T>`
- `map<K,V>`

where `T`, `K`, `V` must themselves be resolvable userType ids.

---

## 4. End-to-end example (Order.yml style)
See a real example:
- `nativa-examples/src/main/resources/authoring/Order.yml`

It demonstrates:
- `ref` + `label` mappings
- nested `fields` mappings for refs
- `sqlView.aliases`
- explicit SQL `AS` aliases matching mapping labels

---

## 5. Code generation from Authoring (Maven)

Nativa’s typical workflow is:
- you author YAML in `src/main/resources/authoring`
- you run codegen to produce POJOs + registries into `target/generated-sources/nativa`

### 5.1 Maven plugin used (`exec-maven-plugin`)

In `nativa-examples`, codegen is wired using `exec-maven-plugin` during `generate-sources`:

```xml
<plugin>
  <groupId>org.codehaus.mojo</groupId>
  <artifactId>exec-maven-plugin</artifactId>
  <version>3.4.1</version>
  <executions>
    <execution>
      <id>nativa-codegen</id>
      <phase>generate-sources</phase>
      <goals><goal>java</goal></goals>
      <configuration>
        <mainClass>io.intellixity.nativa.persistence.codegen.CodegenMain</mainClass>
        <arguments>
          <argument>${project.basedir}/src/main/resources/authoring</argument>
          <argument>${project.build.directory}/generated-sources/nativa</argument>
        </arguments>
        <includeProjectDependencies>true</includeProjectDependencies>
      </configuration>
    </execution>
  </executions>
</plugin>
```

What it does:
- Runs `io.intellixity.nativa.persistence.codegen.CodegenMain`
- Inputs: `${project.basedir}/src/main/resources/authoring`
- Output: `${project.build.directory}/generated-sources/nativa`

### 5.2 Add generated sources to compilation (`build-helper-maven-plugin`)

Because codegen writes Java files under `target/generated-sources/nativa`, `nativa-examples` also adds that folder as a source root during `generate-sources`:

```xml
<plugin>
  <groupId>org.codehaus.mojo</groupId>
  <artifactId>build-helper-maven-plugin</artifactId>
  <version>3.6.0</version>
  <executions>
    <execution>
      <id>add-generated</id>
      <phase>generate-sources</phase>
      <goals><goal>add-source</goal></goals>
      <configuration>
        <sources>
          <source>${project.build.directory}/generated-sources/nativa</source>
        </sources>
      </configuration>
    </execution>
  </executions>
</plugin>
```

### 5.3 How to run codegen

From repo root:

```bash
mvn -pl nativa-examples -am generate-sources
```

Typical dev flow (also runs codegen because it includes `generate-sources`):

```bash
mvn -pl nativa-examples -am compile
```

Where generated code will be written:
- `nativa-examples/target/generated-sources/nativa`

### 5.4 IntelliJ note

If IntelliJ doesn’t automatically recognize the generated folder:
- right-click `nativa-examples/target/generated-sources/nativa`
- **Mark Directory as → Generated Sources Root**


