package io.intellixity.nativa.persistence.authoring.yaml;

import io.intellixity.nativa.persistence.authoring.*;
import org.yaml.snakeyaml.Yaml;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

/**
 * Runtime loader for YAML-driven {@link EntityAuthoring} definitions.
 *
 * <p>This lives in {@code nativa-core} so applications can load authoring at runtime
 * (e.g. DemoApplication/tests). Codegen can also reuse it to load the same YAML inputs.</p>
 */
public final class YamlEntityAuthoringLoader {
  private final Yaml yaml = new Yaml();

  public EntityAuthoring load(Path file) throws IOException {
    List<EntityAuthoring> all = loadAll(file);
    return all.getFirst();
  }

  public List<EntityAuthoring> loadDir(Path dir) throws IOException {
    List<EntityAuthoring> out = new ArrayList<>();
    try (var s = Files.list(dir)) {
      for (Path p : (Iterable<Path>) s::iterator) {
        String name = p.getFileName().toString();
        if (!name.endsWith(".yml") && !name.endsWith(".yaml")) continue;
        out.addAll(loadAll(p));
      }
    }
    return out;
  }

  public List<EntityAuthoring> loadAll(Path file) throws IOException {
    try (InputStream in = Files.newInputStream(file)) {
      Map<String, Object> root = yaml.load(in);
      if (root == null) throw new IllegalArgumentException("Empty YAML: " + file);
      return parseEntityWithInlineTypes(root);
    }
  }

  private static List<EntityAuthoring> parseEntityWithInlineTypes(Map<String, Object> root) {
    String type = String.valueOf(root.get("type"));
    String javaType = String.valueOf(root.getOrDefault("javaType", type));
    boolean generatePojo = Boolean.parseBoolean(String.valueOf(root.getOrDefault("generatePojo", "true")));
    AuthoringKind kind = AuthoringKind.valueOf(String.valueOf(root.getOrDefault("kind", "ENTITY")).toUpperCase());
    String source = strOrNull(root.get("source"));

    List<EntityAuthoring> inline = new ArrayList<>();
    Map<String, FieldDef> fields = parseFieldsWithInline(map(root.get("fields")), pkg(javaType), inline);
    Map<String, ViewDef> views = parseViews(map(root.get("views")));

    EntityAuthoring main = new EntityAuthoring(type, kind, source, javaType, generatePojo, fields, views);
    inline.add(0, main);
    return inline;
  }

  private static Map<String, Object> map(Object o) {
    if (o == null) return new LinkedHashMap<>();
    if (o instanceof Map<?, ?> m) {
      Map<String, Object> out = new LinkedHashMap<>();
      for (var e : m.entrySet()) out.put(String.valueOf(e.getKey()), e.getValue());
      return out;
    }
    throw new IllegalArgumentException("Expected map but got: " + o.getClass());
  }

  private static Map<String, FieldDef> parseFields(Map<String, Object> m) {
    Map<String, FieldDef> out = new LinkedHashMap<>();
    for (var e : m.entrySet()) {
      String name = e.getKey();
      Object v = e.getValue();
      Map<String, Object> fm = (v instanceof Map<?, ?> mm) ? cast(mm) : Map.of("type", String.valueOf(v));

      String typeStr = String.valueOf(fm.get("type"));
      TypeRef type = TypeRefParser.parse(typeStr);

      boolean nullable = Boolean.parseBoolean(String.valueOf(fm.getOrDefault("nullable", "false")));
      boolean key = Boolean.parseBoolean(String.valueOf(fm.getOrDefault("key", "false")));
      boolean autoGenerated = Boolean.parseBoolean(String.valueOf(fm.getOrDefault("autoGenerated", "false")));

      Map<String, Object> attrs = map(fm.get("attrs"));
      out.put(name, new FieldDef(type, nullable, key, autoGenerated, attrs));
    }
    return out;
  }

  private static Map<String, FieldDef> parseFieldsWithInline(Map<String, Object> m,
                                                             String defaultJavaPackage,
                                                             List<EntityAuthoring> inlineOut) {
    Map<String, FieldDef> out = new LinkedHashMap<>();
    for (var e : m.entrySet()) {
      String name = e.getKey();
      Object v = e.getValue();
      Map<String, Object> fm = (v instanceof Map<?, ?> mm) ? cast(mm) : Map.of("type", String.valueOf(v));

      String typeStr = String.valueOf(fm.get("type"));
      TypeRef type = TypeRefParser.parse(typeStr);

      // Inline VALUE type definition: type: value(Address) + fields: { ... }
      if (typeStr != null && typeStr.trim().startsWith("value(") && typeStr.trim().endsWith(")")) {
        String typeId = typeStr.trim().substring("value(".length(), typeStr.trim().length() - 1).trim();
        Map<String, Object> fieldsObj = map(fm.get("fields"));
        Map<String, FieldDef> valueFields = parseFields(fieldsObj);
        String jt = String.valueOf(fm.getOrDefault("javaType", defaultJavaPackage + "." + typeId));
        boolean gen = Boolean.parseBoolean(String.valueOf(fm.getOrDefault("generatePojo", "true")));
        inlineOut.add(new EntityAuthoring(typeId, AuthoringKind.VALUE, null, jt, gen, valueFields, Map.of()));

        // replace field type with ref(typeId) for codegen/type resolution
        type = new RefTypeRef(typeId, null);
      }

      boolean nullable = Boolean.parseBoolean(String.valueOf(fm.getOrDefault("nullable", "false")));
      boolean key = Boolean.parseBoolean(String.valueOf(fm.getOrDefault("key", "false")));
      boolean autoGenerated = Boolean.parseBoolean(String.valueOf(fm.getOrDefault("autoGenerated", "false")));
      Map<String, Object> attrs = map(fm.get("attrs"));
      out.put(name, new FieldDef(type, nullable, key, autoGenerated, attrs));
    }
    return out;
  }

  private static Map<String, ViewDef> parseViews(Map<String, Object> m) {
    Map<String, ViewDef> out = new LinkedHashMap<>();
    for (var e : m.entrySet()) {
      String id = e.getKey();
      Map<String, Object> vm = cast((Map<?, ?>) e.getValue());

      Map<String, Object> mapping = map(vm.get("mapping"));

      SqlViewDef sqlView = null;
      Object sqlViewObj = vm.get("sqlView");
      if (sqlViewObj instanceof Map<?, ?> mm) {
        sqlView = parseSqlView(cast(mm));
      } else if (sqlViewObj != null) {
        throw new IllegalArgumentException("view.sqlView must be a map for view: " + id);
      }

      out.put(id, new ViewDef(id, mapping, sqlView));
    }
    return out;
  }

  private static SqlViewDef parseSqlView(Map<String, Object> m) {
    Object sql = m.get("sql");
    Object projection = m.get("projection");
    boolean schema = Boolean.parseBoolean(String.valueOf(m.getOrDefault("schema", "false")));

    List<SqlAliasDef> aliases = new ArrayList<>();
    Object aliasesObj = m.get("aliases");
    if (aliasesObj instanceof List<?> list) {
      for (Object x : list) {
        if (x == null) continue;
        Map<String, Object> am = map(x);
        aliases.add(new SqlAliasDef(
            strOrNull(am.get("name")),
            strOrNull(am.get("property")),
            strOrNull(am.get("table"))
        ));
      }
    }
    return new SqlViewDef(sql, projection, schema, aliases);
  }

  private static String strOrNull(Object o) {
    if (o == null) return null;
    String s = String.valueOf(o);
    return s.isBlank() ? null : s;
  }

  private static String pkg(String fqcn) {
    if (fqcn == null) return "";
    int i = fqcn.lastIndexOf('.');
    return i < 0 ? "" : fqcn.substring(0, i);
  }

  private static Map<String, Object> cast(Map<?, ?> mm) {
    Map<String, Object> out = new LinkedHashMap<>();
    for (var x : mm.entrySet()) out.put(String.valueOf(x.getKey()), x.getValue());
    return out;
  }
}


